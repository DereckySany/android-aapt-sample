import com.android.sdklib.BuildToolInfo

import java.util.regex.Matcher
import java.util.regex.Pattern
import org.gradle.util.GFileUtils

apply plugin: 'com.android.application'
/**
 * 转换publicTxt为publicXml
 * copy tinker:com.tencent.tinker.build.gradle.task.TinkerResourceIdTask#convertPublicTxtToPublicXml
 */
@SuppressWarnings("GrMethodMayBeStatic")
void convertPublicTxtToPublicXml(File publicTxtFile, File publicXmlFile, boolean withId) {
    if (publicTxtFile == null || publicXmlFile == null || !publicTxtFile.exists() || !publicTxtFile.isFile()) {
        throw new GradleException("publicTxtFile ${publicTxtFile} is not exist or not a file")
    }

    GFileUtils.deleteQuietly(publicXmlFile)
    GFileUtils.mkdirs(publicXmlFile.getParentFile())
    GFileUtils.touch(publicXmlFile)

    project.logger.info "convert publicTxtFile ${publicTxtFile} to publicXmlFile ${publicXmlFile}"

    publicXmlFile.append("<!-- AUTO-GENERATED FILE.  DO NOT MODIFY -->")
    publicXmlFile.append("\n")
    publicXmlFile.append("<resources>")
    publicXmlFile.append("\n")
    Pattern linePattern = Pattern.compile(".*?:(.*?)/(.*?)\\s+=\\s+(.*?)")

    publicTxtFile.eachLine {def line ->
        Matcher matcher = linePattern.matcher(line)
        if (matcher.matches() && matcher.groupCount() == 3) {
            String resType = matcher.group(1)
            String resName = matcher.group(2)
            if (resName.startsWith('$')) {
                project.logger.info "ignore to public res ${resName} because it's a nested resource"
            } else if (resType.equalsIgnoreCase("styleable")) {
                project.logger.info "ignore to public res ${resName} because it's a styleable resource"
            } else {
                if (withId) {
                    publicXmlFile.append("\t<public type=\"${resType}\" name=\"${resName}\" id=\"${matcher.group(3)}\" />\n")
                } else {
                    publicXmlFile.append("\t<public type=\"${resType}\" name=\"${resName}\" />\n")
                }

            }
        }
    }

    publicXmlFile.append("</resources>")
}
android {
    compileSdkVersion 29
    buildToolsVersion '29.0.3'

    defaultConfig {
        applicationId "com.example.aaptdemo"
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    //利用public.txt文件做资源id固定
    //aaptOptions {
    //    File publicTxtFile = project.rootProject.file('public.txt')
    //    //public文件存在，则应用，不存在则生成
    //    if (publicTxtFile.exists()) {
    //        project.logger.error "${publicTxtFile} exists, apply it."
    //        //aapt2添加--stable-ids参数应用
    //        aaptOptions.additionalParameters("--stable-ids", "${publicTxtFile}")
    //    } else {
    //        project.logger.error "${publicTxtFile} not exists, generate it."
    //        //aapt2添加--emit-ids参数生成
    //        aaptOptions.additionalParameters("--emit-ids", "${publicTxtFile}")
    //    }
    //}


    //将public.txt转化为public.xml，并对public.xml进行aapt2的编译将结果复制到${ergeResourceTask.outputDir}
    //下面大部分代码是copy自tinker的源码
    applicationVariants.all { def variant ->
        def mergeResourceTask = project.tasks.findByName("merge${variant.getName().capitalize()}Resources")
        if (mergeResourceTask) {
            mergeResourceTask.doLast {
                //目标转换文件，注意public.xml上级目录必须带values目录，否则aapt2执行时会报非法文件路径
                File publicXmlFile = new File(project.buildDir, "intermediates/res/public/${variant.getDirName()}/values/public.xml")
                //转换public.txt文件为publicXml文件，最后一个参数true标识固定资源id
                convertPublicTxtToPublicXml(project.rootProject.file('public.txt'), publicXmlFile, true)

                def variantData = variant.getMetaClass().getProperty(variant, 'variantData')
                def variantScope = variantData.getScope()
                def globalScope = variantScope.getGlobalScope()
                def androidBuilder = globalScope.getAndroidBuilder()
                def targetInfo = androidBuilder.getTargetInfo()
                def mBuildToolInfo = targetInfo.getBuildTools()
                Map<BuildToolInfo.PathId, String> mPaths = mBuildToolInfo.getMetaClass().getProperty(mBuildToolInfo, "mPaths") as Map<BuildToolInfo.PathId, String>

                project.exec(new Action<ExecSpec>() {
                    @Override
                    void execute(ExecSpec execSpec) {
                        execSpec.executable "${mPaths.get(BuildToolInfo.PathId.AAPT2)}"
                        execSpec.args("compile")
                        execSpec.args("--legacy")
                        execSpec.args("-o")
                        execSpec.args("${mergeResourceTask.outputDir}")
                        execSpec.args("${publicXmlFile}")
                    }
                })
            }
        }
    }
}

dependencies {
}